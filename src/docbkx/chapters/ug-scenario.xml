<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:db="http://docbook.org/ns/docbook" xml:id="ch-ug-scenario" status="draft">
   <title>Defining Scenario</title>
   <para>
      Scenario is a receipt for telling PerfCake what to do. You can specify how PerfCake would
      generate load by configuring a generator, where and what to send by defining a sender and messages.
      To get any measured results such as an average throughput or a memory usage you can use reporting capabilities.
      To check that the responses are correct a validation is available for you to set in the
      scenario. There is also a possibility to specify scenario meta-data by setting the scenario's properties.
   </para>
   <para>The following section describes the scenario's structure.</para>
   <sect1 xml:id="ch-ug-scenario.scenario-xml-structure">
      <title>Scenario XML structure</title>
      <para>
         As you can see from the following listing the scenario is defined by an XML file defined by
         <code>urn:perfcake:scenario:3.0</code>
         namespace
         <footnote>
            <para>
               Schema can be found at
               <link xlink:href="http://schema.perfcake.org/perfcake-scenario-3.0.xsd"/>
            </para>
         </footnote>
         .
         The scenario is divided into several sections: Properties, Generator, Sender, Reporting, Messages and Validation.
      </para>
      <simplesect>
         <title>Scenario structure</title>
         <programlisting language="xml" linenumbering="numbered" startinglinenumber="1"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<scenario xmlns="urn:perfcake:scenario:3.0">

   <!-- Scenario properties (optional) -->
   <properties>
      <property name="..." value="..."/>
      ...
   </properties>
   
   <!-- Generator section (required) -->
   <generator ... >
      ...
   </generator>
   
   <!-- Sender section (required) -->
   <sender ... >
      ...
   </sender>
   
   <!-- Reporting section (optional) -->
   <reporting>
      ...
   </reporting>
   
   <!-- Messages section (optional) -->
   <messages>
      ...
   </messages>
   
   <!-- Validation section (optional) -->
   <validation>
      ...
   </validation>
 </scenario>]]></programlisting>
      </simplesect>
      <sect2>
         <title>Sections of the scenario</title>
         <para>Let's take a look at particular sections of the scenario.</para>
         <simplesect>
            <title>Scenario Properties</title>
            <para>This optional section allows you to add some meta-data about your scenario. It can contain multiple properties.</para>
         </simplesect>
         <simplesect>
            <title>Generator</title>
            <para>Generator section specifies the way how the load is generated. It is mandatory since PerfCake needs to know how to generate load.</para>
            <para>
               The generators are described in more details in
               <xref linkend="ch-ug-generating"/>
               .
            </para>
         </simplesect>
         <simplesect>
            <title>Sender</title>
            <para>Sender section is about the transport (e.g. HTTP, JMS, ...) and the target where the load is directed.
               It is required to be specified in the scenario.
            </para>
            <para>
               More information about the senders can be found in
               <xref linkend="ch-ug-sending.senders"/>
               .
            </para>
         </simplesect>
         <simplesect>
            <title>Reporting</title>
            <para>Reporting module is responsible for gathering metrics and reporting the results to various places in specified moments.
               It is not required to configure the reporting in the scenario but without it the PerfCake has no way of measuring and reporting
               results.
            </para>
            <para>
               The reporting abilities are described in
               <xref linkend="ch-ug-reporting"/>
               .
            </para>
         </simplesect>
         <simplesect>
            <title>Messages</title>
            <para>The messages represent the payload that is transfered by senders to the tested system. It is optional since
               there can be situations where there is no actual message being send.
            </para>
            <para>
               The
               <xref linkend="ch-ug-sending.messages"/>
               describes the messages in more details.
            </para>
         </simplesect>
         <simplesect>
            <title>Validation</title>
            <para>Validation module allows to validate the response messages.</para>
            <para>
               The validation capabilities are described in
               <xref linkend="ch-ug-validation"/>
               .
            </para>
         </simplesect>
      </sect2>
   </sect1>
   <sect1 xml:id="ch-ug-scenario.filtering-properties">
      <title>Filtering properties</title>
      <para>It is possible to use property placeholders in scenarios (and in messages too, see later).
         The placeholders are replaced by the actual value of the particular property or by the default value if specified in a process
         called property filtering.
      </para>
      <para>
         The properties are loaded from system properties and environment properties (in this order). To limit just to one of these sources,
         one can specify a namespace prefix <emphasis role="italic">env.</emphasis> for environment properties and <emphasis role="italic">props.</emphasis> for system properties.
      </para>
      <para>A placeholder has the following format:</para>
      <programlisting><![CDATA['${' + <property name> + (':' + <default value>) + '}']]></programlisting>
      <simplesect>
         <title>An example of a scenario with a property placeholder without the default value:</title>
         <programlisting language="xml" linenumbering="numbered" startinglinenumber="1"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<scenario xmlns="urn:perfcake:scenario:${perfcake.scenario.version}">
   ...
</scenario>]]></programlisting>
      </simplesect>
      <simplesect>
         <title>An example of a scenario with a property placeholder with the default value of "3.0":</title>
         <programlisting language="xml" linenumbering="numbered" startinglinenumber="1"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<scenario xmlns="urn:perfcake:scenario:${perfcake.version:3.0}">
   ...
</scenario>]]></programlisting>
      </simplesect>
      <para>
         The property filtering process is performed in a moment, when a scenario file is loaded
         by PerfCake, before it is parsed. There are no advanced features, just a simmple string replacement for scenario files.
      </para>
      <para>
         The filtering tries to find the property by name. If the property is found, the whole placeholder is replaced by property's actual value.
         If the specified property does not exist, it looks for the default value if it is specified. If so the whole placeholder is replaced by the default value.
         Otherwise it leaves the placeholder in place intact.
      </para>
      <para>
         To provide PerfCake the actual value of the property you can just pass it using an ordinary way:
         <programlisting><![CDATA[-D<property.name>=<property.value>]]></programlisting>
      </para>
      <para>
         Another way is to configure an environment property in the operating system. In case the same property exists both as a system property and as an environment
         property, the system property takes precedence.
      </para>
      <para>There are several properties that exist in PerfCake and that might be usefull in the scenarios
         or messages (e.g. a timestamp of the scenario execution start). The following table describes all available
         internal properties.
      </para>
      <table frame="all" xml:id="ch-ug-scenario.filtering-properties.available-properties-table">
         <title>Available PerfCake internal properties</title>
         <tgroup cols="2" align="left" colsep="1" rowsep="1">
            <colspec colname="property-name" colwidth="1*"/>
            <colspec colname="description" colwidth="2*"/>
            <thead>
               <row>
                  <entry>Property name</entry>
                  <entry>Description</entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>perfcake.encoding</entry>
                  <entry>Default encoding</entry>
               </row>
               <row>
                  <entry>perfcake.messages.dir</entry>
                  <entry>Messages directory</entry>
               </row>
               <row>
                  <entry>perfcake.plugins.dir</entry>
                  <entry>Plugins directory</entry>
               </row>
               <row>
                  <entry>perfcake.properties.file</entry>
                  <entry>Custom properties file</entry>
               </row>
               <row>
                  <entry>perfcake.run.timestamp</entry>
                  <entry>A timestamp of a moment when the scenario execution started</entry>
               </row>
               <row>
                  <entry>perfcake.scenario</entry>
                  <entry>A name of the scenario</entry>
               </row>
               <row>
                  <entry>perfcake.scenarios.dir</entry>
                  <entry>Scenarios directory</entry>
               </row>
            </tbody>
         </tgroup>
      </table>
      <sect2>
        <title>Filtering Messages</title>
        <para>
           Messages stored in separate files can take an advantage of more complex filtering than those with body specified directly in the scenario file.
           This is optimized for performance and uses HTTL Framework.
            <footnote>
                <para>
                    <link xlink:href="http://httl.github.io/en/"/>
                </para>
            </footnote>
             More complex replacements are possible including math operators, string concatenation etc. However, take into account that this might have a negative impact 
             on the maximal message generation speed. It is recommended to create a comparative test without any templates to be sure there is no significant drop in troughput.
            </para>
            <para>
                All system properties are must be prefixed with the <emphasis role="italic">props.</emphasis> namespace declaration. All environment properties must be prefixed 
                with the <emphasis role="italic">env.</emphasis> namespace declaration.
                Internal PerfCake properties (i.e. message number) do not need any prefix. Sequences are accessible through the seq. namespace prefix.
            </para>
            <para>
                While loading the message body from a file, all placeholders with the dollar sign are replaced first (for example <code language="xml">${env.JAVA_HOME}</code>). This is done
                only once and no later changes to the property values take any effect. There is an option to be able to replace a placeholder with a fresh property value each tima a new
                message is created/being sent. Such a property placeholder uses the <emphasis role="italic">at</emphasis> sign (for example <code language="xml">@{props.counter}</code>).
            </para>
            <para>
                To specify a default value for a property, the double pipe character is used. For instance: <code language="xml"><![CDATA[${property_name||default_value}]]></code>
            </para>
            <para>
                Any occurrence of the placeholder can be escaped using the backslash sign. This means that the following placeholders will never get replaced:
                <code language="xml"><![CDATA[\${non-replaceable} \@{ignored-placeholder}]]></code>
            </para>
      </sect2>
   </sect1>
</chapter>
